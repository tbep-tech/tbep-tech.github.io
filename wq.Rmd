---
title: "Get EPCHC Data, Tidy it Up & Perform TBEP Annual WQ Assessment"
author: "Ed Sherwood <esherwood@tbep.org>"
date: "February 4, 2019"
output: 
  html_document: 
    toc: yes
    toc_float: yes
---

Original: [esherwoo77/pull_epc_data:pull_epc_data.Rmd](https://github.com/esherwoo77/pull_epc_data/blob/master/pull_epc_data.Rmd)

```{r setup, include=FALSE}
# libraries
library(tidyverse)
library(lubridate)
library(readxl)
library(curl)
library(leaflet)
library(rmarkdown)
library(here) # gets consistent path based on *.Rproj
library(glue) # easy string creation
library(tbeptools)
# devtools::load_all('../tbeptools/.')
knitr::opts_chunk$set(echo = TRUE)

# paths
# here(): set path based on root of repo where *.Rproj is found
epchc_xlsx    <- here("data-raw/epchc.xlsx")
epcdata_rdata <- here("data-raw/epcdata.RData")

# set Google Drive folder to where sync'd
user <- Sys.info()[["user"]]
dir_gdrive <- case_when(
  user == "Marcus" ~ "C:/Users/Marcus/Google Drive/tbep-tech",
  user == "bbest" ~ "/Users/bbest/Gdrive Ecoquants/projects/tbep-tech")

```

## Download and import EPCHC dataset

```{r epchc_import}
# path to download if not downloaded, path to import
xlsx <- file.path(dir_gdrive, "data/wq/2018_Results_Updated.xls")

# load data and some light formatting
epcdata <- load_epchc_wq(xlsx, download_latest_epchc = F) %>% 
  form_epchc_wq
```


```{r ecphc_validate}
#Display station locations
wqsites <- epcdata %>% 
           select(epchc_station, Latitude, Longitude) %>% 
           unique()                                                   ### WHAT IS THIS - DOES IT SELECT ONLY UNIQUE FULL ROWS?

map <- leaflet(wqsites) %>%                                            ### LOOKS LIKE THIS MAPS LOCATION OF STATIONS IN WQSITES - CAN WE IMPROVE TO PLOT COLOR CODED AVERAGES
              addProviderTiles(providers$CartoDB.Positron) %>% 
              addCircleMarkers(~Longitude, ~Latitude,
                               radius = 6,
                               color = 'black',
                               stroke = FALSE,
                               opacity = 0.8,
                               popup = ~as.character(paste('EPC Station:', epchc_station)), 
                               group = 'Water quality') %>% 
              addLayersControl(overlayGroups = c('Water quality'),
                               options = layersControlOptions(collapsed = FALSE))
map
```

```{r calculate_means}                                          
#Generate annual averages for each bay segment
tbdata <-subset(epcdata, bay_segment != "MTB")                   ### DROPS MTB HERE - DEALS WITH IT LATER 
tbmonchla <- tbdata %>% 
               select(yr, mo, bay_segment, chla) %>%
               drop_na() %>%
               group_by(yr, mo, bay_segment) %>%
               summarise(mean_chla = mean(chla))
tbyrchla <- tbmonchla %>% 
               select(bay_segment, yr, mean_chla) %>% 
               drop_na() %>% 
               group_by(bay_segment, yr) %>% 
               summarise(mean_chla = mean(mean_chla))
  
tbmonsdm <- tbdata %>% 
               select(yr, mo, bay_segment, sd_m) %>%
               drop_na() %>%
               group_by(yr, mo, bay_segment) %>%
               summarise(mean_sdm = mean(sd_m))

tbyrsdm <- tbmonsdm %>% 
               select(bay_segment, yr, mean_sdm) %>% 
               drop_na() %>% 
               group_by(bay_segment, yr) %>% 
               summarise(mean_sdm = mean(mean_sdm))

#Process MTB data using weighted averages of 3 subsegments
mtbdata <- subset(epcdata, bay_segment == "MTB")
mtbdata$baysegment <- ifelse(mtbdata$epchc_station %in% c(9, 11, 81, 84), "MT1",
                             ifelse(mtbdata$epchc_station %in% c(13, 14, 32, 33), "MT2",
                                    ifelse(mtbdata$epchc_station %in% c(16, 19, 28, 82), "MT3", NA)))
mtbmonthlychla <- mtbdata %>%
                select(yr, mo, baysegment, chla) %>% 
                drop_na() %>% 
                group_by(yr, mo, baysegment) %>% 
                summarise(mean_chla = mean(chla))
mtbmonchla <- mtbmonthlychla

mtbmonthlysdm <- mtbdata %>%                                  ### SECCHI DISK
                select(yr, mo, baysegment, sd_m) %>% 
                drop_na() %>% 
                group_by(yr, mo, baysegment) %>% 
                summarise(mean_sd_m = mean(sd_m))
mtbmonsdm <- mtbmonthlysdm

mtbmonchla$chla <- ifelse(mtbmonchla$baysegment=="MT1", mtbmonchla$mean_chla*2108.7,                  ### AREA WEIGHTED ?
                        ifelse(mtbmonchla$baysegment=="MT2", mtbmonchla$mean_chla*1041.9,
                               ifelse(mtbmonchla$baysegment=="MT3", mtbmonchla$mean_chla*974.6, NA)))
mtbmonsdm$sdm <- ifelse(mtbmonsdm$baysegment=="MT1", mtbmonsdm$mean_sd_m*2108.7,
                        ifelse(mtbmonsdm$baysegment=="MT2", mtbmonsdm$mean_sd_m*1041.9,
                               ifelse(mtbmonsdm$baysegment=="MT3", mtbmonsdm$mean_sd_m*974.6, NA)))
mtbmoyrchla <- mtbmonchla %>%
                select(yr, mo, baysegment, chla) %>% 
                drop_na() %>% 
                group_by(yr, mo) %>% 
                summarise(sum_chla = sum(chla)) %>% 
                mutate(mean_chla = sum_chla/4125.2,              ### WEIGHTED AVERAGE MONTHLY
                       bay_segment ="MTB") 

mtbyrchla <- mtbmoyrchla %>%
                select(yr, mean_chla) %>% 
                drop_na() %>% 
                group_by(yr) %>% 
                summarise(mean_chla = mean(mean_chla)) %>% 
                mutate(bay_segment = "MTB")                   ###AVERAGE OF MONTHLY AREA WEIGHTED
  

mtbmoyrsdm <- mtbmonsdm %>%
                select(yr, mo, baysegment, sdm) %>% 
                drop_na() %>% 
                group_by(yr, mo) %>% 
                summarise(sum_sdm = sum(sdm)) %>% 
                mutate(mean_sdm = sum_sdm/4125.2,            ### WEIGHTED AVERAGE sd
                       bay_segment ="MTB")

mtbyrsdm <- mtbmoyrsdm %>%
                select(yr, mean_sdm) %>% 
                drop_na() %>% 
                group_by(yr) %>% 
                summarise(mean_sdm = mean(mean_sdm)) %>% 
                mutate(bay_segment = "MTB")

#Put it all together
chladata <- bind_rows(tbyrchla, mtbyrchla)
chlamodata <- bind_rows(tbmonchla, mtbmoyrchla)
sdmdata <- bind_rows(tbyrsdm, mtbyrsdm)
sdmmodata <- bind_rows(tbmonsdm, mtbmoyrsdm)


### I BELIEVE THE BELOW ARE GEISSON FACTORS FOR sd TO CALCULATE % LIGHT AVAILABILITY
sdmdata$mean_la <- ifelse(sdmdata$bay_segment =="OTB", 1.49/sdmdata$mean_sdm,
                             ifelse(sdmdata$bay_segment =="HB", 1.61/sdmdata$mean_sdm,
                                    ifelse(sdmdata$bay_segment =="MTB", 1.49/sdmdata$mean_sdm,
                                           ifelse(sdmdata$bay_segment =="LTB", 1.84/sdmdata$mean_sdm,NA))))
```

## Plot Mean Annual Chl-a Values by Bay Segment {.tabset}
```{r plot_chla_annual_averages, results='asis'}
bay_segments <- unique(stations$bay_segment)
cols <- c("Annual Mean"="red", "Management Target"="blue", "Regulatory Threshold"="blue", "Small Mag. Exceedance"="blue", "Large Mag. Exceedance"="blue")
for (i in seq_along(bay_segments)) {
   chlaplot <- chladata %>%
                 filter(bay_segment == bay_segments[i] & yr<2019) %>%                           ###   LOOP TO PLOT BY BAYSEGMENT
                 ggplot(aes(x=yr)) +                                                            ###   SEE GARY'S NOTES ON REQUESTED IMPROVEMENTS
                   geom_point(aes(y=mean_chla, colour="Annual Mean"), size=3) +
                   geom_line(aes(y=mean_chla, colour="Annual Mean"), size=0.75) +
                   geom_hline(data=targets, aes(yintercept = as.numeric(chla_thresh[i]),        ###    DO THEY WANT TO ADD OTHER REFERENCE LINES?
                                                colour="Regulatory Threshold")) +
                   ggtitle(paste(targets$name[i])) +
                   geom_text(data=targets, parse = TRUE,
                             aes(1973, as.numeric(chla_thresh[i]),
                                 label = paste(chla_thresh[i],"~ mu * g%.%L^{-1}"),            ### NOT SURE WHAT g%.%L IS BUT ITS A LABEL
                                 hjust = 0.2, vjust = -0.3)) +
                   ylab(expression("Mean Annual Chlorophyll-a ("~ mu * "g\u00B7L"^-1 *")")) +
                   xlab("") +
                   scale_x_continuous(breaks=seq(1973,2019,by=1),                                   ### IS THERE A WAY TO AUTOMATE THIS SO WE DONT HAVE TO MANUALLY SCALE AXIS?
                                      labels=c(1973, rep("",3), 1977, rep("",3), 1981, rep("",3),
                                               1985, rep("",3), 1989, rep("",3), 1993, rep("",3),
                                               1997, rep("",3), 2001, rep("",3), 2005, rep("",3),
                                               2009, rep("",3), 2013, rep("",3), 2017, rep("",2)),
                                      expand = c(0.035,0)) +
                   theme(plot.title = element_text(hjust = 0.5),
                         panel.grid.minor=element_blank(),
                         panel.grid.major=element_blank(),
                         legend.position = c(0.88, 0.95),
                         legend.background = element_rect(fill=NA)) +
                   scale_colour_manual(name="", values = cols,
                                       labels=c("Annual Mean", "Regulatory Threshold"))
   cat("###", paste(targets$name[i]), "\n")
   print(chlaplot)
   cat("\n\n")
} 
```

## Plot Mean Annual Light Attenuation Values by Bay Segment {.tabset}
```{r plot_la_annual_averages, results='asis'}
for (i in seq_along(bay_segments)) {
    sdmplot <- sdmdata %>%
                 filter(bay_segment == bay_segments[i] & yr<2019) %>% 
                 ggplot(aes(x=yr)) + 
                   geom_point(aes(y=mean_la, colour="Annual Mean"), size=3) +
                   geom_line(aes(y=mean_la, colour="Annual Mean"), size=0.75) +
                   geom_hline(data=targets, aes(yintercept = as.numeric(la_target[i]),
                                                colour="Management Target")) +
                   ggtitle(paste(targets$name[i])) +
                   geom_text(data=targets, parse = T,
                             aes(1973, as.numeric(la_target[i]),
                                 label = paste(la_target[i],"~m","^{-1}"),
                                 hjust = 0.3, vjust = -0.3)) +
                   ylab(expression("Mean Annual Light Attenuation (m  " ^-1 *")")) +
                   xlab("") +
                   scale_x_continuous(breaks=seq(1973,2019,by=1),
                                      labels=c(1973, rep("",3), 1977, rep("",3), 1981, rep("",3),
                                               1985, rep("",3), 1989, rep("",3), 1993, rep("",3),
                                               1997, rep("",3), 2001, rep("",3), 2005, rep("",3),
                                               2009, rep("",3), 2013, rep("",3), 2017, rep("",2)),
                                      expand = c(0.035,0)) +
                   theme(plot.title = element_text(hjust = 0.5),
                         panel.grid.minor=element_blank(),
                         panel.grid.major=element_blank(),
                         legend.position = c(0.88, 0.95),
                         legend.background = element_rect(fill=NA)) +
                   scale_colour_manual(name="", values = cols,
                                       labels=c("Annual Mean", "Management Target"))
   cat("###", paste(targets$name[i]), "\n")  
   print(sdmplot)
   cat("\n\n")
} 

```
#### NEED TO USE THE FILES BELOW TO GENERATE THE COLOR CODED TABLE OF RESULTS

## Export Annual Values as a Tidy CSV File
Export final datasets to csv files in 'data-processed' folder.
```{r epchc_export_tidy_data}
write.csv(chladata, file = "./data-processed/TB_Chla_Annual_Means.csv")
write.csv(chlamodata, file = "./data-processed/TB_Chla_Monthly_means.csv")
write.csv(sdmdata, file = "./data-processed/TB_Secchi_Annual_Means.csv")
write.csv(sdmmodata, file = "./data-processed/TB_Secchi_Monthly_means.csv")
```

## Table output

```{r, eval = F}
#library(formattable)
library(gt)

chl_yr <- read_csv(here("data-processed/TB_Chla_Annual_Means.csv"))
#chl_yr %>% select(-X1) %>% View()

chl_yr %>% 
  select(-X1) %>% 
  #View()
  spread(bay_segment, mean_chla) %>% 
  gt() %>% 
  data_color(
    columns = vars(HB, LTB, MTB, OTB), 
    colors = scales::col_numeric(palette = c("red", "yellow", "green"), alpha = NULL, apply_to = "bkgd", autocolor_text = TRUE)
```


